---
title: Funktionale Programmierung und Imperative Programmierung (C#)
ms.date: 07/20/2015
ms.assetid: 5e35c5a0-c949-422a-873b-fca6b2254f57
ms.openlocfilehash: 42c80146a091bfdcff2bbf3ebe1f4ed9a9510e29
ms.sourcegitcommit: 6b308cf6d627d78ee36dbbae8972a310ac7fd6c8
ms.translationtype: HT
ms.contentlocale: de-DE
ms.lasthandoff: 01/23/2019
ms.locfileid: "54518955"
---
# <a name="functional-programming-vs-imperative-programming-c"></a><span data-ttu-id="95a70-102">Funktionale Programmierung und Imperative Programmierung (C#)</span><span class="sxs-lookup"><span data-stu-id="95a70-102">Functional Programming vs. Imperative Programming (C#)</span></span>
<span data-ttu-id="95a70-103">In diesem Thema werden die Gemeinsamkeiten und die Unterschiede der funktionalen Programmierung und der herkömmlichen imperativen (prozeduralen) Programmierung erläutert.</span><span class="sxs-lookup"><span data-stu-id="95a70-103">This topic compares and contrasts functional programming with more traditional imperative (procedural) programming.</span></span>  
  
## <a name="functional-programming-vs-imperative-programming"></a><span data-ttu-id="95a70-104">Funktionale Programmierung und Imperative Programmierung</span><span class="sxs-lookup"><span data-stu-id="95a70-104">Functional Programming vs. Imperative Programming</span></span>  
 <span data-ttu-id="95a70-105">Explizite Aufgabe der *funktionalen Programmierung* ist die Unterstützung eines reinen funktionalen Ansatzes bei der Problemlösung.</span><span class="sxs-lookup"><span data-stu-id="95a70-105">The *functional programming* paradigm was explicitly created to support a pure functional approach to problem solving.</span></span> <span data-ttu-id="95a70-106">Die funktionale Programmierung ist eine Form der *deklarativen Programmierung*.</span><span class="sxs-lookup"><span data-stu-id="95a70-106">Functional programming is a form of *declarative programming*.</span></span> <span data-ttu-id="95a70-107">Im Unterschied dazu unterstützen die meisten normalen Programmiersprachen, darunter auch OOP-Sprachen wie C#, Visual Basic, C++ und Java, in erster Linie die *imperative* (prozedurale) Programmierung.</span><span class="sxs-lookup"><span data-stu-id="95a70-107">In contrast, most mainstream languages, including object-oriented programming (OOP) languages such as C#, Visual Basic, C++, and Java, were designed to primarily support *imperative* (procedural) programming.</span></span>  
  
 <span data-ttu-id="95a70-108">Beim imperativen Ansatz schreibt ein Entwickler Code, der detailliert die Schritte beschreibt, die der Computer zur Erfüllung der Aufgabe ausführen muss.</span><span class="sxs-lookup"><span data-stu-id="95a70-108">With an imperative approach, a developer writes code that describes in exacting detail the steps that the computer must take to accomplish the goal.</span></span> <span data-ttu-id="95a70-109">Diese Form der Programmierung wird mitunter auch als *algorithmische* Programmierung bezeichnet.</span><span class="sxs-lookup"><span data-stu-id="95a70-109">This is sometimes referred to as *algorithmic* programming.</span></span> <span data-ttu-id="95a70-110">Beim funktionalen Ansatz hingegen wird das Problem als Satz von auszuführenden Funktionen formuliert.</span><span class="sxs-lookup"><span data-stu-id="95a70-110">In contrast, a functional approach involves composing the problem as a set of functions to be executed.</span></span> <span data-ttu-id="95a70-111">Sie definieren sorgfältig, was für jede Funktion eingegeben wird und was die jeweilige Funktion zurückgibt.</span><span class="sxs-lookup"><span data-stu-id="95a70-111">You define carefully the input to each function, and what each function returns.</span></span> <span data-ttu-id="95a70-112">In der folgenden Tabelle werden einige der allgemeinen Unterschiede zwischen diesen beiden Ansätzen beschrieben:</span><span class="sxs-lookup"><span data-stu-id="95a70-112">The following table describes some of the general differences between these two approaches.</span></span>  
  
|<span data-ttu-id="95a70-113">Merkmal</span><span class="sxs-lookup"><span data-stu-id="95a70-113">Characteristic</span></span>|<span data-ttu-id="95a70-114">Imperativer Ansatz</span><span class="sxs-lookup"><span data-stu-id="95a70-114">Imperative approach</span></span>|<span data-ttu-id="95a70-115">Funktionaler Ansatz</span><span class="sxs-lookup"><span data-stu-id="95a70-115">Functional approach</span></span>|  
|--------------------|-------------------------|-------------------------|  
|<span data-ttu-id="95a70-116">Schwerpunkt bei der Programmierung</span><span class="sxs-lookup"><span data-stu-id="95a70-116">Programmer focus</span></span>|<span data-ttu-id="95a70-117">Art und Weise der Ausführung von Aufgaben (Algorithmen) und der Überwachung von Statusänderungen</span><span class="sxs-lookup"><span data-stu-id="95a70-117">How to perform tasks (algorithms) and how to track changes in state.</span></span>|<span data-ttu-id="95a70-118">Art der gewünschten Informationen und der erforderlichen Transformationen</span><span class="sxs-lookup"><span data-stu-id="95a70-118">What information is desired and what transformations are required.</span></span>|  
|<span data-ttu-id="95a70-119">Statusänderungen</span><span class="sxs-lookup"><span data-stu-id="95a70-119">State changes</span></span>|<span data-ttu-id="95a70-120">wichtig</span><span class="sxs-lookup"><span data-stu-id="95a70-120">Important.</span></span>|<span data-ttu-id="95a70-121">nicht existent</span><span class="sxs-lookup"><span data-stu-id="95a70-121">Non-existent.</span></span>|  
|<span data-ttu-id="95a70-122">Reihenfolge der Ausführung</span><span class="sxs-lookup"><span data-stu-id="95a70-122">Order of execution</span></span>|<span data-ttu-id="95a70-123">wichtig</span><span class="sxs-lookup"><span data-stu-id="95a70-123">Important.</span></span>|<span data-ttu-id="95a70-124">weniger wichtig</span><span class="sxs-lookup"><span data-stu-id="95a70-124">Low importance.</span></span>|  
|<span data-ttu-id="95a70-125">Primäre Datenflusskontrolle</span><span class="sxs-lookup"><span data-stu-id="95a70-125">Primary flow control</span></span>|<span data-ttu-id="95a70-126">Schleifen, Bedingungen und Funktions- (Methoden-)Aufrufe</span><span class="sxs-lookup"><span data-stu-id="95a70-126">Loops, conditionals, and function (method) calls.</span></span>|<span data-ttu-id="95a70-127">Funktionsaufrufe, einschließlich Rekursion</span><span class="sxs-lookup"><span data-stu-id="95a70-127">Function calls, including recursion.</span></span>|  
|<span data-ttu-id="95a70-128">Primäre Manipulationseinheit</span><span class="sxs-lookup"><span data-stu-id="95a70-128">Primary manipulation unit</span></span>|<span data-ttu-id="95a70-129">Instanzen von Strukturen oder Klassen</span><span class="sxs-lookup"><span data-stu-id="95a70-129">Instances of structures or classes.</span></span>|<span data-ttu-id="95a70-130">Funktionen als erstklassige Objekte und Datensammlungen</span><span class="sxs-lookup"><span data-stu-id="95a70-130">Functions as first-class objects and data collections.</span></span>|  
  
 <span data-ttu-id="95a70-131">Die meisten Sprachen unterstützen zwar ein bestimmtes Programmierparadigma, viele allgemeine Sprachen sind aber ausreichend flexibel, um mehrere Paradigmen zu unterstützen.</span><span class="sxs-lookup"><span data-stu-id="95a70-131">Although most languages were designed to support a specific programming paradigm, many general languages are flexible enough to support multiple paradigms.</span></span> <span data-ttu-id="95a70-132">So können z. B. die meisten Sprachen, die Funktionszeiger enthalten, zur glaubwürdigen Unterstützung der funktionalen Programmierung verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="95a70-132">For example, most languages that contain function pointers can be used to credibly support functional programming.</span></span> <span data-ttu-id="95a70-133">Darüber hinaus enthält C# auch explizite Spracherweiterungen, darunter Lambda-Ausdrücke und Typableitung, die die funktionale Programmierung unterstützen.</span><span class="sxs-lookup"><span data-stu-id="95a70-133">Furthermore, C# includes explicit language extensions to support functional programming, including lambda expressions and type inference.</span></span> <span data-ttu-id="95a70-134">Eine Form der deklarativen, funktionalen Programmierung ist die LINQ-Technologie.</span><span class="sxs-lookup"><span data-stu-id="95a70-134">LINQ technology is a form of declarative, functional programming.</span></span>  
  
## <a name="functional-programming-using-xslt"></a><span data-ttu-id="95a70-135">Funktionale Programmierung mit XSLT</span><span class="sxs-lookup"><span data-stu-id="95a70-135">Functional Programming Using XSLT</span></span>  
 <span data-ttu-id="95a70-136">Viele XSLT-Entwickler sind mit dem reinen funktionalen Ansatz vertraut.</span><span class="sxs-lookup"><span data-stu-id="95a70-136">Many XSLT developers are familiar with the pure functional approach.</span></span> <span data-ttu-id="95a70-137">Der effektivste Weg bei der Entwicklung eines XSLT-Stylesheets besteht darin, jede Vorlage als isolierte, zusammensetzbare Transformation zu behandeln.</span><span class="sxs-lookup"><span data-stu-id="95a70-137">The most effective way to develop an XSLT style sheet is to treat each template as an isolated, composable transformation.</span></span> <span data-ttu-id="95a70-138">Die Reihenfolge der Ausführung ist dabei ohne jede Bedeutung.</span><span class="sxs-lookup"><span data-stu-id="95a70-138">The order of execution is completely de-emphasized.</span></span> <span data-ttu-id="95a70-139">XSLT lässt keine Nebenwirkungen zu (lediglich die Escapemechanismen für die Ausführung von prozeduralem Code können Nebenwirkungen mit sich bringen, die zu funktionaler Unreinheit führen).</span><span class="sxs-lookup"><span data-stu-id="95a70-139">XSLT does not allow side effects (with the exception that escaping mechanisms for executing procedural code can introduce side effects that result in functional impurity).</span></span> <span data-ttu-id="95a70-140">XSLT ist zwar ein wirksames Tool, dennoch sind einige seiner Eigenschaften nicht optimal.</span><span class="sxs-lookup"><span data-stu-id="95a70-140">However, although XSLT is an effective tool, some of its characteristics are not optimal.</span></span> <span data-ttu-id="95a70-141">So führt z. B. das Ausdrücken von Programmierkonstrukten in XML dazu, dass Code relativ weitschweifig und damit schwierig zu unterhalten ist.</span><span class="sxs-lookup"><span data-stu-id="95a70-141">For example, expressing programming constructs in XML makes code relatively verbose, and therefore difficult to maintain.</span></span> <span data-ttu-id="95a70-142">Auch die schwere Abhängigkeit von der Rekursion zur Flusssteuerung kann dazu führen, dass Code schwer lesbar ist.</span><span class="sxs-lookup"><span data-stu-id="95a70-142">Also, the heavy reliance on recursion for flow control can result in code that is hard to read.</span></span> <span data-ttu-id="95a70-143">Weitere Informationen zu XSLT finden Sie unter [XSLT-Transformationen](../../../../standard/data/xml/xslt-transformations.md).</span><span class="sxs-lookup"><span data-stu-id="95a70-143">For more information about XSLT, see [XSLT Transformations](../../../../standard/data/xml/xslt-transformations.md).</span></span>  
  
 <span data-ttu-id="95a70-144">Dennoch hat XSLT bewiesen, dass die Verwendung eines reinen funktionalen Ansatzes bei der Transformierung von XML von einer Form in eine andere sinnvoll ist.</span><span class="sxs-lookup"><span data-stu-id="95a70-144">However, XSLT has proved the value of using a pure functional approach for transforming XML from one shape to another.</span></span> <span data-ttu-id="95a70-145">Die reine funktionale Programmierung mit LINQ to XML ähnelt in vielerlei Hinsicht XSLT.</span><span class="sxs-lookup"><span data-stu-id="95a70-145">Pure functional programming with LINQ to XML is similar in many ways to XSLT.</span></span> <span data-ttu-id="95a70-146">Mit den Programmierkonstrukten von LINQ to XML und C# können Sie reine funktionale Transformationen schreiben, die besser lesbar und verwaltbar sind als XSLT.</span><span class="sxs-lookup"><span data-stu-id="95a70-146">However, the programming constructs introduced by LINQ to XML and C#  allow you to write pure functional transformations that are more readable and maintainable than XSLT.</span></span>  
  
## <a name="advantages-of-pure-functions"></a><span data-ttu-id="95a70-147">Vorteile von reinen Funktionen</span><span class="sxs-lookup"><span data-stu-id="95a70-147">Advantages of Pure Functions</span></span>  
 <span data-ttu-id="95a70-148">Der Hauptgrund für die Implementierung von funktionalen Transformationen als reinen Funktionen (Pure-Funktionen) besteht darin, dass reine Funktionen zusammenstellbar sind, d. h., sie sind in sich abgeschlossen und zustandslos.</span><span class="sxs-lookup"><span data-stu-id="95a70-148">The primary reason to implement functional transformations as pure functions is that pure functions are composable: that is, self-contained and stateless.</span></span> <span data-ttu-id="95a70-149">Diese Eigenschaften bieten u. a. die folgenden Vorteile:</span><span class="sxs-lookup"><span data-stu-id="95a70-149">These characteristics bring a number of benefits, including the following:</span></span>  
  
-   <span data-ttu-id="95a70-150">Bessere Lesbarkeit und Verwaltbarkeit:</span><span class="sxs-lookup"><span data-stu-id="95a70-150">Increased readability and maintainability.</span></span> <span data-ttu-id="95a70-151">Jede Funktion ist für die Erledigung einer bestimmten Aufgabe anhand ihrer Argumente vorgesehen,</span><span class="sxs-lookup"><span data-stu-id="95a70-151">This is because each function is designed to accomplish a specific task given its arguments.</span></span> <span data-ttu-id="95a70-152">ohne sich dabei auf einen externen Zustand zu verlassen.</span><span class="sxs-lookup"><span data-stu-id="95a70-152">The function does not rely on any external state.</span></span>  
  
-   <span data-ttu-id="95a70-153">Einfachere reiterative Entwicklung:</span><span class="sxs-lookup"><span data-stu-id="95a70-153">Easier reiterative development.</span></span> <span data-ttu-id="95a70-154">Da der Code einfacher umgestaltet werden kann, können Änderungen am Entwurf oft leichter implementiert werden.</span><span class="sxs-lookup"><span data-stu-id="95a70-154">Because the code is easier to refactor, changes to design are often easier to implement.</span></span> <span data-ttu-id="95a70-155">Nehmen wir z. B. an, Sie schreiben eine komplizierte Transformation und stellen dann fest, dass sich ein Teil des Codes in der Transformation mehrmals wiederholt.</span><span class="sxs-lookup"><span data-stu-id="95a70-155">For example, suppose you write a complicated transformation, and then realize that some code is repeated several times in the transformation.</span></span> <span data-ttu-id="95a70-156">Bei der Umgestaltung mit einer reinen Methode können Sie Ihre reine Methode ganz nach Belieben aufrufen, ohne auf irgendwelche Nebenwirkungen Rücksicht nehmen zu müssen.</span><span class="sxs-lookup"><span data-stu-id="95a70-156">If you refactor through a pure method, you can call your pure method at will without worrying about side effects.</span></span>  
  
-   <span data-ttu-id="95a70-157">Einfacheres Testen und Debuggen:</span><span class="sxs-lookup"><span data-stu-id="95a70-157">Easier testing and debugging.</span></span> <span data-ttu-id="95a70-158">Da reine Funktionen einfacher in Isolation getestet werden können, können Sie Testcode schreiben, der die reine Funktion mit typischen Werten, gültigen Randfällen und ungültigen Randfällen aufruft.</span><span class="sxs-lookup"><span data-stu-id="95a70-158">Because pure functions can more easily be tested in isolation, you can write test code that calls the pure function with typical values, valid edge cases, and invalid edge cases.</span></span>  
  
## <a name="transitioning-for-oop-developers"></a><span data-ttu-id="95a70-159">Was müssen OOP-Entwickler beachten?</span><span class="sxs-lookup"><span data-stu-id="95a70-159">Transitioning for OOP Developers</span></span>  
 <span data-ttu-id="95a70-160">Bei der traditionellen objektorientierten Programmierung (OOP) verwenden die meisten Entwickler beim Programmieren den imperativen/prozeduralen Stil.</span><span class="sxs-lookup"><span data-stu-id="95a70-160">In traditional object-oriented programming (OOP), most developers are accustomed to programming in the imperative/procedural style.</span></span> <span data-ttu-id="95a70-161">Für den Umstieg auf die Entwicklung in einem reinen funktionalen Stil müssen die Entwickler umdenken und ihre Herangehensweise an die Entwicklung ändern.</span><span class="sxs-lookup"><span data-stu-id="95a70-161">To switch to developing in a pure functional style, they have to make a transition in their thinking and their approach to development.</span></span>  
  
 <span data-ttu-id="95a70-162">Zur Lösung von Problemen entwerfen OOP-Entwickler Klassenhierarchien, konzentrieren sich auf die richtige Kapselung und denken in Klassenvertragskategorien.</span><span class="sxs-lookup"><span data-stu-id="95a70-162">To solve problems, OOP developers design class hierarchies, focus on proper encapsulation, and think in terms of class contracts.</span></span> <span data-ttu-id="95a70-163">Im Vordergrund stehen das Verhalten und der Status von Objekttypen, und zu diesem Zweck werden Sprachfunktionen wie Klassen, Schnittstellen, Vererbung und Polymorphie bereitgestellt.</span><span class="sxs-lookup"><span data-stu-id="95a70-163">The behavior and state of object types are paramount, and language features, such as classes, interfaces, inheritance, and polymorphism, are provided to address these concerns.</span></span>  
  
 <span data-ttu-id="95a70-164">Dagegen werden die Berechnungsprobleme bei der funktionalen Programmierung als Übung für die Auswertung reiner funktionaler Transformationen von Datensammlungen angesehen.</span><span class="sxs-lookup"><span data-stu-id="95a70-164">In contrast, functional programming approaches computational problems as an exercise in the evaluation of pure functional transformations of data collections.</span></span> <span data-ttu-id="95a70-165">Bei der funktionalen Programmierung werden Zustands- und änderbare Daten vermieden, stattdessen steht die Anwendung von Funktionen im Mittelpunkt.</span><span class="sxs-lookup"><span data-stu-id="95a70-165">Functional programming avoids state and mutable data, and instead emphasizes the application of functions.</span></span>  
  
 <span data-ttu-id="95a70-166">Glücklicherweise erfordert C# keinen kompletten Umstieg auf die funktionale Programmierung, da sowohl der imperative als auch der funktionale Programmierungsansatz unterstützt wird.</span><span class="sxs-lookup"><span data-stu-id="95a70-166">Fortunately, C# doesn't require the full leap to functional programming, because it supports both imperative and functional programming approaches.</span></span> <span data-ttu-id="95a70-167">Der Entwickler kann daher selbst entscheiden, welcher Ansatz für ein bestimmtes Szenario am geeignetsten ist.</span><span class="sxs-lookup"><span data-stu-id="95a70-167">A developer can choose which approach is most appropriate for a particular scenario.</span></span> <span data-ttu-id="95a70-168">Bei vielen Programme werden beide Ansätze häufig miteinander kombiniert.</span><span class="sxs-lookup"><span data-stu-id="95a70-168">In fact, programs often combine both approaches.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="95a70-169">Siehe auch</span><span class="sxs-lookup"><span data-stu-id="95a70-169">See also</span></span>

- [<span data-ttu-id="95a70-170">Introduction to Pure Functional Transformations (C#) (Einführung in reine funktionale Transformationen (C#))</span><span class="sxs-lookup"><span data-stu-id="95a70-170">Introduction to Pure Functional Transformations (C#)</span></span>](../../../../csharp/programming-guide/concepts/linq/introduction-to-pure-functional-transformations.md)
- [<span data-ttu-id="95a70-171">XSLT Transformations (XSLT-Transformationen)</span><span class="sxs-lookup"><span data-stu-id="95a70-171">XSLT Transformations</span></span>](../../../../standard/data/xml/xslt-transformations.md)
- [<span data-ttu-id="95a70-172">Refactoring in reine Funktionen (C#)</span><span class="sxs-lookup"><span data-stu-id="95a70-172">Refactoring Into Pure Functions (C#)</span></span>](../../../../csharp/programming-guide/concepts/linq/refactoring-into-pure-functions.md)
